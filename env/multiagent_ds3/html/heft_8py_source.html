<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DASH-Sim Manual: heft.py Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DARPA_logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DASH-Sim Manual
   </div>
   <div id="projectbrief">Domain-Focused Advanced Software-Reconfigurable Heterogenous SoC Simulator</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('heft_8py_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">heft.py</div>  </div>
</div><!--header-->
<div class="contents">
<a href="heft_8py.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno"><a class="line" href="namespaceheft.html">    1</a></span>&#160;<span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="stringliteral">@brief internal implementation used for scheduling a task DAG with any of the HEFT family of algorithms</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">from</span> collections <span class="keyword">import</span> deque, namedtuple</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">from</span> math <span class="keyword">import</span> inf</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keyword">from</span> heft.gantt <span class="keyword">import</span> showGanttChart</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="keyword">from</span> types <span class="keyword">import</span> SimpleNamespace</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">from</span> enum <span class="keyword">import</span> Enum</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">import</span> argparse</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="keyword">import</span> logging</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="keyword">import</span> sys</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160; </div>
<div class="line"><a name="l00018"></a><span class="lineno"><a class="line" href="namespaceheft.html#af161499c257fa10f7a1f00a5bc01c33d">   18</a></span>&#160;logger = logging.getLogger(<span class="stringliteral">&#39;heft&#39;</span>)</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; </div>
<div class="line"><a name="l00020"></a><span class="lineno"><a class="line" href="namespaceheft.html#ad59279ba9e1b640c2333b0ef64012397">   20</a></span>&#160;ScheduleEvent = namedtuple(<span class="stringliteral">&#39;ScheduleEvent&#39;</span>, <span class="stringliteral">&#39;task start end proc&#39;</span>)</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="stringliteral">Default computation matrix - taken from Topcuoglu 2002 HEFT paper</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="stringliteral">computation matrix: v x q matrix with v tasks and q PEs</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno"><a class="line" href="namespaceheft.html#abf5bc88e3b4ab3d279402212aab69f58">   26</a></span>&#160;W0 = np.array([</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    [14, 16, 9],</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    [13, 19, 18],</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    [11, 13, 19],</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    [13, 8, 17],</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    [12, 13, 10],</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    [13, 16, 9],</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    [7, 15, 11],</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    [5, 11, 14],</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    [18, 12, 20],</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    [21, 7, 16]</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;])</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160; </div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="stringliteral">Default communication matrix - not listed in Topcuoglu 2002 HEFT paper</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="stringliteral">communication matrix: q x q matrix with q PEs</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="stringliteral">Note that a communication cost of 0 is used for a given processor to itself</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><a name="l00045"></a><span class="lineno"><a class="line" href="namespaceheft.html#a5df77e7c32a0ed23d219c1b37f7a7a36">   45</a></span>&#160;C0 = np.array([</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    [0, 1, 1],</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    [1, 0, 1],</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    [1, 1, 0]</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;])</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160; </div>
<div class="line"><a name="l00051"></a><span class="lineno"><a class="line" href="classheft_1_1_rank_metric.html">   51</a></span>&#160;<span class="keyword">class </span><a class="code" href="classheft_1_1_rank_metric.html">RankMetric</a>(Enum):</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="stringliteral">    @brief The RankMetric class is an Enum that can be used to select which rank metric we should use to prioritize the nodes in the incoming DAG prior to processor allocation</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="stringliteral">    There are four different rank metrics available.\n</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="stringliteral">    - MEAN: Prioritize tasks based on average estimates for computation time\n</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="stringliteral">    - WORST: Prioritize tasks based on worst case estimates for computation time\n</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="stringliteral">    - BEST: Prioritize tasks based on best case estimates for computation time\n</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="stringliteral">    - EDP: Prioritize tasks based on average estimates for EDP impact</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00061"></a><span class="lineno"><a class="line" href="classheft_1_1_rank_metric.html#a77cb63b08568522b7685d32bf6b5de62">   61</a></span>&#160;    MEAN = <span class="stringliteral">&quot;MEAN&quot;</span>  </div>
<div class="line"><a name="l00062"></a><span class="lineno"><a class="line" href="classheft_1_1_rank_metric.html#aca47aa0440af43b2891bbe95f320e975">   62</a></span>&#160;    WORST = <span class="stringliteral">&quot;WORST&quot;</span> </div>
<div class="line"><a name="l00063"></a><span class="lineno"><a class="line" href="classheft_1_1_rank_metric.html#a397625da6b6bb47e5908a5fa9cc7d428">   63</a></span>&#160;    BEST = <span class="stringliteral">&quot;BEST&quot;</span> </div>
<div class="line"><a name="l00064"></a><span class="lineno"><a class="line" href="classheft_1_1_rank_metric.html#a503230c7b5b0410b68b8f5129e5c6895">   64</a></span>&#160;    EDP = <span class="stringliteral">&quot;EDP&quot;</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160; </div>
<div class="line"><a name="l00066"></a><span class="lineno"><a class="line" href="classheft_1_1_op_mode.html">   66</a></span>&#160;<span class="keyword">class </span><a class="code" href="classheft_1_1_op_mode.html">OpMode</a>(Enum):</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="stringliteral">    @brief The OpMode class is an Enum that can be used to select which method should be used to perform processor allocation decisions based on the sorted list of tasks</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="stringliteral">    There are four different operational modes available.\n</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="stringliteral">    - EFT: Schedule tasks to the processor that gives them their earliest finish time.\n</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="stringliteral">    - EDP_REL: Schedule tasks to the processor that minimizes their estimated EDP with some tweaks in place to encourage load balancing.\n</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="stringliteral">    - EDP_ABS: Schedule tasks to the processor that minimizes their estimated EDP with no regard for load balancing.\n</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="stringliteral">    - ENERGY: Schedule tasks to the processor that minimizes their estimated total energy consumption.</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00076"></a><span class="lineno"><a class="line" href="classheft_1_1_op_mode.html#a572875e73aa1710f596b961e7e4a9fca">   76</a></span>&#160;    EFT = <span class="stringliteral">&quot;EFT&quot;</span></div>
<div class="line"><a name="l00077"></a><span class="lineno"><a class="line" href="classheft_1_1_op_mode.html#a86d7867ee178132202bf658429653348">   77</a></span>&#160;    EDP_REL = <span class="stringliteral">&quot;EDP RELATIVE&quot;</span></div>
<div class="line"><a name="l00078"></a><span class="lineno"><a class="line" href="classheft_1_1_op_mode.html#a1c6e95664981509802f32896790e5c77">   78</a></span>&#160;    EDP_ABS = <span class="stringliteral">&quot;EDP ABSOLUTE&quot;</span></div>
<div class="line"><a name="l00079"></a><span class="lineno"><a class="line" href="classheft_1_1_op_mode.html#a47d42971563a29a3f921a714d0c62049">   79</a></span>&#160;    ENERGY = <span class="stringliteral">&quot;ENERGY&quot;</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160; </div>
<div class="line"><a name="l00081"></a><span class="lineno"><a class="line" href="namespaceheft.html#adff2de444daf22653cbcf0dba5bc7c9e">   81</a></span>&#160;<span class="keyword">def </span><a class="code" href="namespaceheft.html#adff2de444daf22653cbcf0dba5bc7c9e">schedule_dag</a>(dag, computation_matrix=W0, communication_matrix=C0, proc_schedules=None, time_offset=0, relabel_nodes=True, rank_metric=RankMetric.MEAN, **kwargs):</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="stringliteral">    Given an application DAG and a set of matrices specifying PE bandwidth and (task, pe) execution times, computes the HEFT schedule</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="stringliteral">    of that DAG onto that set of PEs </span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="stringliteral">    @param dag: a NetworkX DiGraph instance that contains all the tasks to be scheduled as well as their dependency and communication volume relationships</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="stringliteral">    @param computation_matrix: the matrix of task to PE computation cost estimates used to inform scheduling decisions</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="stringliteral">    @param communication_matrix: the matrix of PE to PE communication cost estimates used to inform scheduling decisions</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="stringliteral">    @param proc_schedules: if existing schedules need to be passed in to HEFT (i.e. we are not scheduling onto an idle system), then they can be passed in as fixed constraints here</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="stringliteral">    @param time_offset: if the schedule here should be generated relative to some time offset rather than the current instance, specify so here</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="stringliteral">    @param relabel_nodes: if the nodes in the incoming DAG need to be relabeled to not conflict with tasks specified in the proc_schedules constraints, specify so here</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="stringliteral">    @param rank_metric: specify the RankMetric enum to be used in scheduling this DAG</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="stringliteral">    @param kwargs: optional kwargs (op_mode - can be used to specify the operating mode, power_dict - contains a matrix of PE to power cost estimates used to inform power-aware scheduling decisions)</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">if</span> proc_schedules == <span class="keywordtype">None</span>:</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        proc_schedules = {}</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160; </div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    _self = {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <span class="stringliteral">&#39;computation_matrix&#39;</span>: computation_matrix,</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="stringliteral">&#39;communication_matrix&#39;</span>: communication_matrix,</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="stringliteral">&#39;task_schedules&#39;</span>: {},</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="stringliteral">&#39;proc_schedules&#39;</span>: proc_schedules,</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="stringliteral">&#39;numExistingJobs&#39;</span>: 0,</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="stringliteral">&#39;time_offset&#39;</span>: time_offset,</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="stringliteral">&#39;root_node&#39;</span>: <span class="keywordtype">None</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    }</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    _self = SimpleNamespace(**_self)</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160; </div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">for</span> proc <span class="keywordflow">in</span> proc_schedules:</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        _self.numExistingJobs = _self.numExistingJobs + len(proc_schedules[proc])</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160; </div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">if</span> relabel_nodes:</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        dag = nx.relabel_nodes(dag, dict(map(<span class="keyword">lambda</span> node: (node, node+_self.numExistingJobs), list(dag.nodes()))))</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="comment">#Negates any offsets that would have been needed had the jobs been relabeled</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        _self.numExistingJobs = 0</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160; </div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(_self.numExistingJobs + len(_self.computation_matrix)):</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        _self.task_schedules[i] = <span class="keywordtype">None</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(_self.communication_matrix)):</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keywordflow">if</span> i <span class="keywordflow">not</span> <span class="keywordflow">in</span> _self.proc_schedules:</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;            _self.proc_schedules[i] = []</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160; </div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="keywordflow">for</span> proc <span class="keywordflow">in</span> proc_schedules:</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <span class="keywordflow">for</span> schedule_event <span class="keywordflow">in</span> proc_schedules[proc]:</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            _self.task_schedules[schedule_event.task] = schedule_event</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160; </div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment"># Nodes with no successors cause the any expression to be empty    </span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    root_node = [node <span class="keywordflow">for</span> node <span class="keywordflow">in</span> dag.nodes() <span class="keywordflow">if</span> <span class="keywordflow">not</span> any(<span class="keyword">True</span> <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> dag.predecessors(node))]</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="keyword">assert</span> len(root_node) == 1, f<span class="stringliteral">&quot;Expected a single root node, found {len(root_node)}&quot;</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    root_node = root_node[0]</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    _self.root_node = root_node</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160; </div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    logger.debug(<span class="stringliteral">&quot;&quot;</span>); logger.debug(<span class="stringliteral">&quot;====================== Performing Rank-U Computation ======================\n&quot;</span>); logger.debug(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    _compute_ranku(_self, dag, metric=rank_metric, **kwargs)</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160; </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    logger.debug(<span class="stringliteral">&quot;&quot;</span>); logger.debug(<span class="stringliteral">&quot;====================== Computing EFT for each (task, processor) pair and scheduling in order of decreasing Rank-U ======================&quot;</span>); logger.debug(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    sorted_nodes = sorted(dag.nodes(), key=<span class="keyword">lambda</span> node: dag.nodes()[node][<span class="stringliteral">&#39;ranku&#39;</span>], reverse=<span class="keyword">True</span>)</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="keywordflow">if</span> sorted_nodes[0] != root_node:</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        logger.debug(<span class="stringliteral">&quot;Root node was not the first node in the sorted list. Must be a zero-cost and zero-weight placeholder node. Rearranging it so it is scheduled first\n&quot;</span>)</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        idx = sorted_nodes.index(root_node)</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        sorted_nodes[idx], sorted_nodes[0] = sorted_nodes[0], sorted_nodes[idx]</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    <span class="keywordflow">for</span> node <span class="keywordflow">in</span> sorted_nodes:</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keywordflow">if</span> _self.task_schedules[node] <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            <span class="keywordflow">continue</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        minTaskSchedule = <a class="code" href="namespaceheft.html#ad59279ba9e1b640c2333b0ef64012397">ScheduleEvent</a>(node, inf, inf, -1)</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        minEDP = inf</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        op_mode = kwargs.get(<span class="stringliteral">&quot;op_mode&quot;</span>, OpMode.EFT)</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="keywordflow">if</span> op_mode == OpMode.EDP_ABS:</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keyword">assert</span> <span class="stringliteral">&quot;power_dict&quot;</span> <span class="keywordflow">in</span> kwargs, <span class="stringliteral">&quot;In order to perform EDP-based processor assignment, a power_dict is required&quot;</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            taskschedules = []</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            minScheduleStart = inf</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160; </div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            <span class="keywordflow">for</span> proc <span class="keywordflow">in</span> range(len(communication_matrix)):</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                taskschedule = _compute_eft(_self, dag, node, proc)</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                edp_t = ((taskschedule.end - taskschedule.start)**2) * kwargs[<span class="stringliteral">&quot;power_dict&quot;</span>][node][proc]</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                <span class="keywordflow">if</span> (edp_t &lt; minEDP):</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                    minEDP = edp_t</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                    minTaskSchedule = taskschedule</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                <span class="keywordflow">elif</span> (edp_t == minEDP <span class="keywordflow">and</span> taskschedule.end &lt; minTaskSchedule.end):</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                    minTaskSchedule = taskschedule</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        </div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">elif</span> op_mode == OpMode.EDP_REL:</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            <span class="keyword">assert</span> <span class="stringliteral">&quot;power_dict&quot;</span> <span class="keywordflow">in</span> kwargs, <span class="stringliteral">&quot;In order to perform EDP-based processor assignment, a power_dict is required&quot;</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            taskschedules = []</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            minScheduleStart = inf</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160; </div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            <span class="keywordflow">for</span> proc <span class="keywordflow">in</span> range(len(communication_matrix)):</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                taskschedules.append(_compute_eft(_self, dag, node, proc))</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                <span class="keywordflow">if</span> taskschedules[proc].start &lt; minScheduleStart:</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                    minScheduleStart = taskschedules[proc].start</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160; </div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            <span class="keywordflow">for</span> taskschedule <span class="keywordflow">in</span> taskschedules:</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                <span class="comment"># Use the makespan relative to the earliest potential assignment to encourage load balancing</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                edp_t = ((taskschedule.end - minScheduleStart)**2) * kwargs[<span class="stringliteral">&quot;power_dict&quot;</span>][node][taskschedule.proc]</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                <span class="keywordflow">if</span> (edp_t &lt; minEDP):</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                    minEDP = edp_t</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                    minTaskSchedule = taskschedule</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                <span class="keywordflow">elif</span> (edp_t == minEDP <span class="keywordflow">and</span> taskschedule.end &lt; minTaskSchedule.end):</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                    minTaskSchedule = taskschedule</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keywordflow">elif</span> op_mode == OpMode.ENERGY:</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            <span class="keyword">assert</span> <span class="keyword">False</span>, <span class="stringliteral">&quot;Feature not implemented&quot;</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="keyword">assert</span> <span class="stringliteral">&quot;power_dict&quot;</span> <span class="keywordflow">in</span> kwargs, <span class="stringliteral">&quot;In order to perform Energy-based processor assignment, a power_dict is required&quot;</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        </div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keywordflow">for</span> proc <span class="keywordflow">in</span> range(len(communication_matrix)):</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                taskschedule = _compute_eft(_self, dag, node, proc)</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                <span class="keywordflow">if</span> (taskschedule.end &lt; minTaskSchedule.end):</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                    minTaskSchedule = taskschedule</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        _self.task_schedules[node] = minTaskSchedule</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        _self.proc_schedules[minTaskSchedule.proc].append(minTaskSchedule)</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        _self.proc_schedules[minTaskSchedule.proc] = sorted(_self.proc_schedules[minTaskSchedule.proc], key=<span class="keyword">lambda</span> schedule_event: (schedule_event.end, schedule_event.start))</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="keywordflow">if</span> logger.isEnabledFor(logging.DEBUG):</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;            logger.debug(<span class="stringliteral">&#39;\n&#39;</span>)</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            <span class="keywordflow">for</span> proc, jobs <span class="keywordflow">in</span> _self.proc_schedules.items():</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                logger.debug(f<span class="stringliteral">&quot;Processor {proc} has the following jobs:&quot;</span>)</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                logger.debug(f<span class="stringliteral">&quot;\t{jobs}&quot;</span>)</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            logger.debug(<span class="stringliteral">&#39;\n&#39;</span>)</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        <span class="keywordflow">for</span> proc <span class="keywordflow">in</span> range(len(_self.proc_schedules)):</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;            <span class="keywordflow">for</span> job <span class="keywordflow">in</span> range(len(_self.proc_schedules[proc])-1):</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                first_job = _self.proc_schedules[proc][job]</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                second_job = _self.proc_schedules[proc][job+1]</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                <span class="keyword">assert</span> first_job.end &lt;= second_job.start, \</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                f<span class="stringliteral">&quot;Jobs on a particular processor must finish before the next can begin, but job {first_job.task} on processor {first_job.proc} ends at {first_job.end} and its successor {second_job.task} starts at {second_job.start}&quot;</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    </div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    dict_output = {}</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordflow">for</span> proc_num, proc_tasks <span class="keywordflow">in</span> _self.proc_schedules.items():</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <span class="keywordflow">for</span> idx, task <span class="keywordflow">in</span> enumerate(proc_tasks):</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            <span class="keywordflow">if</span> idx &gt; 0 <span class="keywordflow">and</span> (proc_tasks[idx-1].end - proc_tasks[idx-1].start &gt; 0):</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                dict_output[task.task] = (proc_num, idx, [proc_tasks[idx-1].task])</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                dict_output[task.task] = (proc_num, idx, [])</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160; </div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="keywordflow">return</span> _self.proc_schedules, _self.task_schedules, dict_output</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160; </div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="keyword">def </span>_scale_by_operating_freq(_self, **kwargs):</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keywordflow">if</span> <span class="stringliteral">&quot;operating_freqs&quot;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> kwargs:</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        logger.debug(<span class="stringliteral">&quot;No operating frequency argument is present, assuming at max frequency and values are unchanged&quot;</span>)</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        <span class="keywordflow">return</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">return</span> <span class="comment">#TODO</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="comment">#for pe_num, freq in enumerate(kwargs[&quot;operating_freqs&quot;]):</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        <span class="comment">#_self.computation_matrix[:, pe_num] = _self.computation_matrix[:, pe_num] * (1 + compute_DVFS_performance_slowdown(pe_num, freq))</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160; </div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="keyword">def </span>_compute_ranku(_self, dag, metric=RankMetric.MEAN, **kwargs):</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="stringliteral">    Uses a basic BFS approach to traverse upwards through the graph assigning ranku along the way</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    terminal_node = [node <span class="keywordflow">for</span> node <span class="keywordflow">in</span> dag.nodes() <span class="keywordflow">if</span> <span class="keywordflow">not</span> any(<span class="keyword">True</span> <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> dag.successors(node))]</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keyword">assert</span> len(terminal_node) == 1, f<span class="stringliteral">&quot;Expected a single terminal node, found {len(terminal_node)}&quot;</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    terminal_node = terminal_node[0]</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160; </div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="comment">#TODO: Should this be configurable?</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="comment">#avgCommunicationCost = np.mean(_self.communication_matrix[np.where(_self.communication_matrix &gt; 0)])</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    diagonal_mask = np.ones(_self.communication_matrix.shape, dtype=bool)</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    np.fill_diagonal(diagonal_mask, 0)</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    avgCommunicationCost = np.mean(_self.communication_matrix[diagonal_mask])</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">for</span> edge <span class="keywordflow">in</span> dag.edges():</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        logger.debug(f<span class="stringliteral">&quot;Assigning {edge}&#39;s average weight based on average communication cost. {float(dag.get_edge_data(*edge)[&#39;weight&#39;])} =&gt; {float(dag.get_edge_data(*edge)[&#39;weight&#39;]) / avgCommunicationCost}&quot;</span>)</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        nx.set_edge_attributes(dag, { edge: float(dag.get_edge_data(*edge)[<span class="stringliteral">&#39;weight&#39;</span>]) / avgCommunicationCost }, <span class="stringliteral">&#39;avgweight&#39;</span>)</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160; </div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="comment"># Utilize a masked array so that np.mean, etc, calculations ignore the entries that are inf</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    comp_matrix_masked = np.ma.masked_where(_self.computation_matrix == inf, _self.computation_matrix)</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160; </div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    nx.set_node_attributes(dag, { terminal_node: np.mean(comp_matrix_masked[terminal_node-_self.numExistingJobs]) }, <span class="stringliteral">&quot;ranku&quot;</span>)</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    visit_queue = deque(dag.predecessors(terminal_node))</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160; </div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="keywordflow">while</span> visit_queue:</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        node = visit_queue.pop()</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="keywordflow">while</span> _node_can_be_processed(_self, dag, node) <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keyword">True</span>:</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            <span class="keywordflow">try</span>:</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                node2 = visit_queue.pop()</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            <span class="keywordflow">except</span> IndexError:</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                <span class="keywordflow">raise</span> RuntimeError(f<span class="stringliteral">&quot;Node {node} cannot be processed, and there are no other nodes in the queue to process instead!&quot;</span>)</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            visit_queue.appendleft(node)</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            node = node2</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        logger.debug(f<span class="stringliteral">&quot;Assigning ranku for node: {node}&quot;</span>)</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        <span class="keywordflow">if</span> metric == RankMetric.MEAN:</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            max_successor_ranku = -1</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="keywordflow">for</span> succnode <span class="keywordflow">in</span> dag.successors(node):</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                logger.debug(f<span class="stringliteral">&quot;\tLooking at successor node: {succnode}&quot;</span>)</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                logger.debug(f<span class="stringliteral">&quot;\tThe edge weight from node {node} to node {succnode} is {dag[node][succnode][&#39;avgweight&#39;]}, and the ranku for node {node} is {dag.nodes()[succnode][&#39;ranku&#39;]}&quot;</span>)</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                val = float(dag[node][succnode][<span class="stringliteral">&#39;avgweight&#39;</span>]) + dag.nodes()[succnode][<span class="stringliteral">&#39;ranku&#39;</span>]</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                <span class="keywordflow">if</span> val &gt; max_successor_ranku:</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                    max_successor_ranku = val</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            <span class="keyword">assert</span> max_successor_ranku &gt;= 0, f<span class="stringliteral">&quot;Expected maximum successor ranku to be greater or equal to 0 but was {max_successor_ranku}&quot;</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            nx.set_node_attributes(dag, { node: np.mean(comp_matrix_masked[node-_self.numExistingJobs]) + max_successor_ranku }, <span class="stringliteral">&quot;ranku&quot;</span>)</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        </div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        <span class="keywordflow">elif</span> metric == RankMetric.WORST:</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            max_successor_ranku = -1</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            max_node_idx = np.where(comp_matrix_masked[node-_self.numExistingJobs] == max(comp_matrix_masked[node-_self.numExistingJobs]))[0][0]</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;            logger.debug(f<span class="stringliteral">&quot;\tNode {node} has maximum computation cost of {comp_matrix_masked[node-_self.numExistingJobs][max_node_idx]} on processor {max_node_idx}&quot;</span>)</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            <span class="keywordflow">for</span> succnode <span class="keywordflow">in</span> dag.successors(node):</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                logger.debug(f<span class="stringliteral">&quot;\tLooking at successor node: {succnode}&quot;</span>)</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                max_succ_idx = np.where(comp_matrix_masked[succnode-_self.numExistingJobs] == max(comp_matrix_masked[succnode-_self.numExistingJobs]))[0][0]</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                logger.debug(f<span class="stringliteral">&quot;\tNode {succnode} has maximum computation cost of {comp_matrix_masked[succnode-_self.numExistingJobs][max_succ_idx]} on processor {max_succ_idx}&quot;</span>)</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                val = _self.communication_matrix[max_node_idx, max_succ_idx] + dag.nodes()[succnode][<span class="stringliteral">&#39;ranku&#39;</span>]</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                <span class="keywordflow">if</span> val &gt; max_successor_ranku:</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                    max_successor_ranku = val</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            <span class="keyword">assert</span> max_successor_ranku &gt;= 0, f<span class="stringliteral">&quot;Expected maximum successor ranku to be greater or equal to 0 but was {max_successor_ranku}&quot;</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;            nx.set_node_attributes(dag, { node: comp_matrix_masked[node-_self.numExistingJobs, max_node_idx] + max_successor_ranku}, <span class="stringliteral">&quot;ranku&quot;</span>)</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        </div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <span class="keywordflow">elif</span> metric == RankMetric.BEST:</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            min_successor_ranku = inf</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            min_node_idx = np.where(comp_matrix_masked[node-_self.numExistingJobs] == min(comp_matrix_masked[node-_self.numExistingJobs]))[0][0]</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            logger.debug(f<span class="stringliteral">&quot;\tNode {node} has minimum computation cost on processor {min_node_idx}&quot;</span>)</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            <span class="keywordflow">for</span> succnode <span class="keywordflow">in</span> dag.successors(node):</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                logger.debug(f<span class="stringliteral">&quot;\tLooking at successor node: {succnode}&quot;</span>)</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                min_succ_idx = np.where(comp_matrix_masked[succnode-_self.numExistingJobs] == min(comp_matrix_masked[succnode-_self.numExistingJobs]))[0][0]</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                logger.debug(f<span class="stringliteral">&quot;\tThis successor node has minimum computation cost on processor {min_succ_idx}&quot;</span>)</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                val = _self.communication_matrix[min_node_idx, min_succ_idx] + dag.nodes()[succnode][<span class="stringliteral">&#39;ranku&#39;</span>]</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                <span class="keywordflow">if</span> val &lt; min_successor_ranku:</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                    min_successor_ranku = val</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="keyword">assert</span> min_successor_ranku &gt;= 0, f<span class="stringliteral">&quot;Expected minimum successor ranku to be greater or equal to 0 but was {min_successor_ranku}&quot;</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            nx.set_node_attributes(dag, { node: comp_matrix_masked[node-_self.numExistingJobs, min_node_idx] + min_successor_ranku}, <span class="stringliteral">&quot;ranku&quot;</span>)</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        </div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        <span class="keywordflow">elif</span> metric == RankMetric.EDP:</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            <span class="keyword">assert</span> <span class="stringliteral">&quot;power_dict&quot;</span> <span class="keywordflow">in</span> kwargs, <span class="stringliteral">&quot;In order to perform EDP-based Rank Method, a power_dict is required&quot;</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            power_dict = kwargs.get(<span class="stringliteral">&quot;power_dict&quot;</span>, np.array([[]]))</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            power_dict_masked = np.ma.masked_where(power_dict[node] == inf, power_dict[node])</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;            max_successor_ranku = -1</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            <span class="keywordflow">for</span> succnode <span class="keywordflow">in</span> dag.successors(node):</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                logger.debug(f<span class="stringliteral">&quot;\tLooking at successor node: {succnode}&quot;</span>)</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                logger.debug(f<span class="stringliteral">&quot;\tThe edge weight from node {node} to node {succnode} is {dag[node][succnode][&#39;avgweight&#39;]}, and the ranku for node {node} is {dag.nodes()[succnode][&#39;ranku&#39;]}&quot;</span>)</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                val = float(dag[node][succnode][<span class="stringliteral">&#39;avgweight&#39;</span>]) + dag.nodes()[succnode][<span class="stringliteral">&#39;ranku&#39;</span>]</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                <span class="keywordflow">if</span> val &gt; max_successor_ranku:</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                    max_successor_ranku = val</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            <span class="keyword">assert</span> max_successor_ranku &gt;= 0, f<span class="stringliteral">&quot;Expected maximum successor ranku to be greater or equal to 0 but was {max_successor_ranku}&quot;</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            avg_edp = np.mean(comp_matrix_masked[node-_self.numExistingJobs])**2 * np.mean(power_dict_masked)</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            nx.set_node_attributes(dag, { node: avg_edp + max_successor_ranku }, <span class="stringliteral">&quot;ranku&quot;</span>)</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        </div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            <span class="keywordflow">raise</span> RuntimeError(f<span class="stringliteral">&quot;Unrecognied Rank-U metric {metric}, unable to compute upward rank&quot;</span>)</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160; </div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        visit_queue.extendleft([prednode <span class="keywordflow">for</span> prednode <span class="keywordflow">in</span> dag.predecessors(node) <span class="keywordflow">if</span> prednode <span class="keywordflow">not</span> <span class="keywordflow">in</span> visit_queue])</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    </div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    logger.debug(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="keywordflow">for</span> node <span class="keywordflow">in</span> dag.nodes():</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        logger.debug(f<span class="stringliteral">&quot;Node: {node}, Rank U: {dag.nodes()[node][&#39;ranku&#39;]}&quot;</span>)</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160; </div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="keyword">def </span>_node_can_be_processed(_self, dag, node):</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="stringliteral">    Validates that a node is able to be processed in Rank U calculations. Namely, that all of its successors have their Rank U values properly assigned</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="stringliteral">    Otherwise, errors can occur in processing DAGs of the form</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="stringliteral">    A</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="stringliteral">    |\</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="stringliteral">    | B</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="stringliteral">    |/</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="stringliteral">    C</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="stringliteral">    Where C enqueues A and B, A is popped off, and it is unable to be processed because B&#39;s Rank U has not been computed</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="keywordflow">for</span> succnode <span class="keywordflow">in</span> dag.successors(node):</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        <span class="keywordflow">if</span> <span class="stringliteral">&#39;ranku&#39;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> dag.nodes()[succnode]:</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            logger.debug(f<span class="stringliteral">&quot;Attempted to compute the Rank U for node {node} but found that it has an unprocessed successor {dag.nodes()[succnode]}. Will try with the next node in the queue&quot;</span>)</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160; </div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="keyword">def </span>_compute_eft(_self, dag, node, proc):</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="stringliteral">    Computes the EFT of a particular node if it were scheduled on a particular processor</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="stringliteral">    It does this by first looking at all predecessor tasks of a particular node and determining the earliest time a task would be ready for execution (ready_time)</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="stringliteral">    It then looks at the list of tasks scheduled on this particular processor and determines the earliest time (after ready_time) a given node can be inserted into this processor&#39;s queue</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    ready_time = _self.time_offset</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    logger.debug(f<span class="stringliteral">&quot;Computing EFT for node {node} on processor {proc}&quot;</span>)</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="keywordflow">for</span> prednode <span class="keywordflow">in</span> list(dag.predecessors(node)):</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        predjob = _self.task_schedules[prednode]</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <span class="keyword">assert</span> predjob != <span class="keywordtype">None</span>, f<span class="stringliteral">&quot;Predecessor nodes must be scheduled before their children, but node {node} has an unscheduled predecessor of {prednode}&quot;</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        logger.debug(f<span class="stringliteral">&quot;\tLooking at predecessor node {prednode} with job {predjob} to determine ready time&quot;</span>)</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        <span class="keywordflow">if</span> _self.communication_matrix[predjob.proc, proc] == 0:</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;            ready_time_t = predjob.end</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;            ready_time_t = predjob.end + dag[predjob.task][node][<span class="stringliteral">&#39;weight&#39;</span>] / _self.communication_matrix[predjob.proc, proc]</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        logger.debug(f<span class="stringliteral">&quot;\tNode {prednode} can have its data routed to processor {proc} by time {ready_time_t}&quot;</span>)</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        <span class="keywordflow">if</span> ready_time_t &gt; ready_time:</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            ready_time = ready_time_t</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    logger.debug(f<span class="stringliteral">&quot;\tReady time determined to be {ready_time}&quot;</span>)</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160; </div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    computation_time = _self.computation_matrix[node-_self.numExistingJobs, proc]</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    job_list = _self.proc_schedules[proc]</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="keywordflow">for</span> idx <span class="keywordflow">in</span> range(len(job_list)):</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        prev_job = job_list[idx]</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        <span class="keywordflow">if</span> idx == 0:</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;            <span class="keywordflow">if</span> (prev_job.start - computation_time) - ready_time &gt; 0:</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                logger.debug(f<span class="stringliteral">&quot;Found an insertion slot before the first job {prev_job} on processor {proc}&quot;</span>)</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                job_start = ready_time</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                min_schedule = <a class="code" href="namespaceheft.html#ad59279ba9e1b640c2333b0ef64012397">ScheduleEvent</a>(node, job_start, job_start+computation_time, proc)</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                <span class="keywordflow">break</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;        <span class="keywordflow">if</span> idx == len(job_list)-1:</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;            job_start = max(ready_time, prev_job.end)</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;            min_schedule = <a class="code" href="namespaceheft.html#ad59279ba9e1b640c2333b0ef64012397">ScheduleEvent</a>(node, job_start, job_start + computation_time, proc)</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            <span class="keywordflow">break</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        next_job = job_list[idx+1]</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        <span class="comment">#Start of next job - computation time == latest we can start in this window</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="comment">#Max(ready_time, previous job&#39;s end) == earliest we can start in this window</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        <span class="comment">#If there&#39;s space in there, schedule in it</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        logger.debug(f<span class="stringliteral">&quot;\tLooking to fit a job of length {computation_time} into a slot of size {next_job.start - max(ready_time, prev_job.end)}&quot;</span>)</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">if</span> (next_job.start - computation_time) - max(ready_time, prev_job.end) &gt;= 0:</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;            job_start = max(ready_time, prev_job.end)</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            logger.debug(f<span class="stringliteral">&quot;\tInsertion is feasible. Inserting job with start time {job_start} and end time {job_start + computation_time} into the time slot [{prev_job.end}, {next_job.start}]&quot;</span>)</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            min_schedule = <a class="code" href="namespaceheft.html#ad59279ba9e1b640c2333b0ef64012397">ScheduleEvent</a>(node, job_start, job_start + computation_time, proc)</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;            <span class="keywordflow">break</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="comment">#For-else loop: the else executes if the for loop exits without break-ing, which in this case means the number of jobs on this processor are 0</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        min_schedule = <a class="code" href="namespaceheft.html#ad59279ba9e1b640c2333b0ef64012397">ScheduleEvent</a>(node, ready_time, ready_time + computation_time, proc)</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    logger.debug(f<span class="stringliteral">&quot;\tFor node {node} on processor {proc}, the EFT is {min_schedule}&quot;</span>)</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="keywordflow">return</span> min_schedule    </div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160; </div>
<div class="line"><a name="l00391"></a><span class="lineno"><a class="line" href="namespaceheft.html#a2d04907ad708a6510d6438eaf8f6394e">  391</a></span>&#160;<span class="keyword">def </span><a class="code" href="namespaceheft.html#a2d04907ad708a6510d6438eaf8f6394e">readCsvToNumpyMatrix</a>(csv_file):</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="stringliteral">    Given an input file consisting of a comma separated list of numeric values with a single header row and header column, </span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="stringliteral">    this function reads that data into a numpy matrix and strips the top row and leftmost column</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    <span class="keyword">with</span> open(csv_file) <span class="keyword">as</span> fd:</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        logger.debug(f<span class="stringliteral">&quot;Reading the contents of {csv_file} into a matrix&quot;</span>)</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;        contents = fd.read()</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        contentsList = contents.split(<span class="stringliteral">&#39;\n&#39;</span>)</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        contentsList = list(map(<span class="keyword">lambda</span> line: line.split(<span class="stringliteral">&#39;,&#39;</span>), contentsList))</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        contentsList = contentsList[0:len(contentsList)-1] <span class="keywordflow">if</span> contentsList[len(contentsList)-1] == [<span class="stringliteral">&#39;&#39;</span>] <span class="keywordflow">else</span> contentsList</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        </div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        matrix = np.array(contentsList)</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        matrix = np.delete(matrix, 0, 0) <span class="comment"># delete the first row (entry 0 along axis 0)</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        matrix = np.delete(matrix, 0, 1) <span class="comment"># delete the first column (entry 0 along axis 1)</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        matrix = matrix.astype(float)</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        logger.debug(f<span class="stringliteral">&quot;After deleting the first row and column of input data, we are left with this matrix:\n{matrix}&quot;</span>)</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        <span class="keywordflow">return</span> matrix</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160; </div>
<div class="line"><a name="l00410"></a><span class="lineno"><a class="line" href="namespaceheft.html#a6b8cf64ba45eb9fab32f9e1ca8d45481">  410</a></span>&#160;<span class="keyword">def </span><a class="code" href="namespaceheft.html#a6b8cf64ba45eb9fab32f9e1ca8d45481">readCsvToDict</a>(csv_file):</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="stringliteral">    Given an input file consisting of a comma separated list of numeric values with a single header row and header column, </span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="stringliteral">    this function reads that data into a dictionary with keys that are node numbers and values that are the CSV lists</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="keyword">with</span> open(csv_file) <span class="keyword">as</span> fd:</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        matrix = <a class="code" href="namespaceheft.html#a2d04907ad708a6510d6438eaf8f6394e">readCsvToNumpyMatrix</a>(csv_file)</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        </div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        outputDict = {}</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        <span class="keywordflow">for</span> row_num, row <span class="keywordflow">in</span> enumerate(matrix):</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;            outputDict[row_num] = row</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        <span class="keywordflow">return</span> outputDict</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160; </div>
<div class="line"><a name="l00423"></a><span class="lineno"><a class="line" href="namespaceheft.html#a739465acaab3bbeadea539d26f1f8967">  423</a></span>&#160;<span class="keyword">def </span><a class="code" href="namespaceheft.html#a739465acaab3bbeadea539d26f1f8967">readDagMatrix</a>(dag_file, show_dag=False):</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="stringliteral">    Given an input file consisting of a connectivity matrix, reads and parses it into a networkx Directional Graph (DiGraph)</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    matrix = <a class="code" href="namespaceheft.html#a2d04907ad708a6510d6438eaf8f6394e">readCsvToNumpyMatrix</a>(dag_file)</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160; </div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    dag = nx.DiGraph(matrix)</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    dag.remove_edges_from(</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        <span class="comment"># Remove all edges with weight of 0 since we have no placeholder for &quot;this edge doesn&#39;t exist&quot; in the input file</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        [edge <span class="keywordflow">for</span> edge <span class="keywordflow">in</span> dag.edges() <span class="keywordflow">if</span> dag.get_edge_data(*edge)[<span class="stringliteral">&#39;weight&#39;</span>] == <span class="stringliteral">&#39;0.0&#39;</span>]</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    )</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160; </div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keywordflow">if</span> show_dag:</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        nx.draw(dag, pos=nx.nx_pydot.graphviz_layout(dag, prog=<span class="stringliteral">&#39;dot&#39;</span>), with_labels=<span class="keyword">True</span>)</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        plt.show()</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160; </div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordflow">return</span> dag</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160; </div>
<div class="line"><a name="l00441"></a><span class="lineno"><a class="line" href="namespaceheft.html#aaeb46a6ae00e284c982ae2779662366c">  441</a></span>&#160;<span class="keyword">def </span><a class="code" href="namespaceheft.html#aaeb46a6ae00e284c982ae2779662366c">generate_argparser</a>():</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;!</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="stringliteral">    For when this heft library is being invoked as a standalone commandline application, generate an argparser</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    parser = argparse.ArgumentParser(description=<span class="stringliteral">&quot;A tool for finding HEFT schedules for given DAG task graphs&quot;</span>)</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-d&quot;</span>, <span class="stringliteral">&quot;--dag_file&quot;</span>, </div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                        help=<span class="stringliteral">&quot;File containing input DAG to be scheduled. Uses default 10 node dag from Topcuoglu 2002 if none given.&quot;</span>, </div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                        type=str, default=<span class="stringliteral">&quot;test/canonicalgraph_task_connectivity.csv&quot;</span>)</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-p&quot;</span>, <span class="stringliteral">&quot;--pe_connectivity_file&quot;</span>, </div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                        help=<span class="stringliteral">&quot;File containing connectivity/bandwidth information about PEs. Uses a default 3x3 matrix from Topcuoglu 2002 if none given.&quot;</span>, </div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                        type=str, default=<span class="stringliteral">&quot;test/canonicalgraph_resource_BW.csv&quot;</span>)</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-t&quot;</span>, <span class="stringliteral">&quot;--task_execution_file&quot;</span>, </div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                        help=<span class="stringliteral">&quot;File containing execution times of each task on each particular PE. Uses a default 10x3 matrix from Topcuoglu 2002 if none given.&quot;</span>, </div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                        type=str, default=<span class="stringliteral">&quot;test/canonicalgraph_task_exe_time.csv&quot;</span>)</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-l&quot;</span>, <span class="stringliteral">&quot;--loglevel&quot;</span>, </div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                        help=<span class="stringliteral">&quot;The log level to be used in this module. Default: INFO&quot;</span>, </div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                        type=str, default=<span class="stringliteral">&quot;INFO&quot;</span>, dest=<span class="stringliteral">&quot;loglevel&quot;</span>, choices=[<span class="stringliteral">&quot;DEBUG&quot;</span>, <span class="stringliteral">&quot;INFO&quot;</span>, <span class="stringliteral">&quot;WARNING&quot;</span>, <span class="stringliteral">&quot;ERROR&quot;</span>, <span class="stringliteral">&quot;CRITICAL&quot;</span>])</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;--metric&quot;</span>,</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                        help=<span class="stringliteral">&quot;Specify which metric to use when performing upward rank calculation&quot;</span>,</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                        type=RankMetric, default=RankMetric.MEAN, dest=<span class="stringliteral">&quot;rank_metric&quot;</span>, choices=list(RankMetric))</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;--showDAG&quot;</span>, </div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                        help=<span class="stringliteral">&quot;Switch used to enable display of the incoming task DAG&quot;</span>, </div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                        dest=<span class="stringliteral">&quot;showDAG&quot;</span>, action=<span class="stringliteral">&quot;store_true&quot;</span>)</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;--showGantt&quot;</span>, </div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                        help=<span class="stringliteral">&quot;Switch used to enable display of the final scheduled Gantt chart&quot;</span>, </div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;                        dest=<span class="stringliteral">&quot;showGantt&quot;</span>, action=<span class="stringliteral">&quot;store_true&quot;</span>)</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="keywordflow">return</span> parser</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160; </div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div>
<div class="line"><a name="l00470"></a><span class="lineno"><a class="line" href="namespaceheft.html#a004361fa8f849881a8a4ffbb6db96eb6">  470</a></span>&#160;    argparser = <a class="code" href="namespaceheft.html#aaeb46a6ae00e284c982ae2779662366c">generate_argparser</a>()</div>
<div class="line"><a name="l00471"></a><span class="lineno"><a class="line" href="namespaceheft.html#a882d103d58a65403c4a2fb02bdbdbb38">  471</a></span>&#160;    args = argparser.parse_args()</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160; </div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    logger.setLevel(logging.getLevelName(args.loglevel))</div>
<div class="line"><a name="l00474"></a><span class="lineno"><a class="line" href="namespaceheft.html#a2604fc2d6da06c804588d56ffacd8322">  474</a></span>&#160;    consolehandler = logging.StreamHandler()</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    consolehandler.setLevel(logging.getLevelName(args.loglevel))</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    consolehandler.setFormatter(logging.Formatter(<span class="stringliteral">&quot;%(levelname)8s : %(name)16s : %(message)s&quot;</span>))</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    logger.addHandler(consolehandler)</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160; </div>
<div class="line"><a name="l00479"></a><span class="lineno"><a class="line" href="namespaceheft.html#a9b46bb36fab0ee96c355473eaff18eba">  479</a></span>&#160;    communication_matrix = <a class="code" href="namespaceheft.html#a2d04907ad708a6510d6438eaf8f6394e">readCsvToNumpyMatrix</a>(args.pe_connectivity_file)</div>
<div class="line"><a name="l00480"></a><span class="lineno"><a class="line" href="namespaceheft.html#ab82a1c9cc7f9aea8131e8a68cd7e3c69">  480</a></span>&#160;    computation_matrix = <a class="code" href="namespaceheft.html#a2d04907ad708a6510d6438eaf8f6394e">readCsvToNumpyMatrix</a>(args.task_execution_file)</div>
<div class="line"><a name="l00481"></a><span class="lineno"><a class="line" href="namespaceheft.html#a270afc79b6393d3e3732db4f5eaeeb9d">  481</a></span>&#160;    dag = <a class="code" href="namespaceheft.html#a739465acaab3bbeadea539d26f1f8967">readDagMatrix</a>(args.dag_file, args.showDAG) </div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160; </div>
<div class="line"><a name="l00483"></a><span class="lineno"><a class="line" href="namespaceheft.html#a362de2ed5630d05dc7cc142206c8d114">  483</a></span>&#160;    processor_schedules, _, _ = <a class="code" href="namespaceheft.html#adff2de444daf22653cbcf0dba5bc7c9e">schedule_dag</a>(dag, communication_matrix=communication_matrix, computation_matrix=computation_matrix, rank_metric=args.rank_metric)</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    <span class="keywordflow">for</span> proc, jobs <span class="keywordflow">in</span> processor_schedules.items():</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;        logger.info(f<span class="stringliteral">&quot;Processor {proc} has the following jobs:&quot;</span>)</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        logger.info(f<span class="stringliteral">&quot;\t{jobs}&quot;</span>)</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keywordflow">if</span> args.showGantt:</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        <a class="code" href="namespacegantt.html#abd2f59dcc6c876c3e48081b122d6ae48">showGanttChart</a>(processor_schedules)</div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceheft_html_ad59279ba9e1b640c2333b0ef64012397"><div class="ttname"><a href="namespaceheft.html#ad59279ba9e1b640c2333b0ef64012397">heft.ScheduleEvent</a></div><div class="ttdeci">ScheduleEvent</div><div class="ttdef"><b>Definition:</b> <a href="heft_8py_source.html#l00020">heft.py:20</a></div></div>
<div class="ttc" id="aclassheft_1_1_op_mode_html"><div class="ttname"><a href="classheft_1_1_op_mode.html">heft.OpMode</a></div><div class="ttdoc">The OpMode class is an Enum that can be used to select which method should be used to perform process...</div><div class="ttdef"><b>Definition:</b> <a href="heft_8py_source.html#l00066">heft.py:66</a></div></div>
<div class="ttc" id="anamespaceheft_html_a739465acaab3bbeadea539d26f1f8967"><div class="ttname"><a href="namespaceheft.html#a739465acaab3bbeadea539d26f1f8967">heft.readDagMatrix</a></div><div class="ttdeci">def readDagMatrix(dag_file, show_dag=False)</div><div class="ttdoc">Given an input file consisting of a connectivity matrix, reads and parses it into a networkx Directio...</div><div class="ttdef"><b>Definition:</b> <a href="heft_8py_source.html#l00423">heft.py:423</a></div></div>
<div class="ttc" id="anamespaceheft_html_adff2de444daf22653cbcf0dba5bc7c9e"><div class="ttname"><a href="namespaceheft.html#adff2de444daf22653cbcf0dba5bc7c9e">heft.schedule_dag</a></div><div class="ttdeci">def schedule_dag(dag, computation_matrix=W0, communication_matrix=C0, proc_schedules=None, time_offset=0, relabel_nodes=True, rank_metric=RankMetric.MEAN, **kwargs)</div><div class="ttdoc">Given an application DAG and a set of matrices specifying PE bandwidth and (task, pe) execution times...</div><div class="ttdef"><b>Definition:</b> <a href="heft_8py_source.html#l00081">heft.py:81</a></div></div>
<div class="ttc" id="anamespacegantt_html_abd2f59dcc6c876c3e48081b122d6ae48"><div class="ttname"><a href="namespacegantt.html#abd2f59dcc6c876c3e48081b122d6ae48">gantt.showGanttChart</a></div><div class="ttdeci">def showGanttChart(proc_schedules)</div><div class="ttdoc">Given a dictionary of processor-task schedules, displays a Gantt chart generated using Matplotlib.</div><div class="ttdef"><b>Definition:</b> <a href="heft_2gantt_8py_source.html#l00010">heft/gantt.py:10</a></div></div>
<div class="ttc" id="anamespaceheft_html_a6b8cf64ba45eb9fab32f9e1ca8d45481"><div class="ttname"><a href="namespaceheft.html#a6b8cf64ba45eb9fab32f9e1ca8d45481">heft.readCsvToDict</a></div><div class="ttdeci">def readCsvToDict(csv_file)</div><div class="ttdoc">Given an input file consisting of a comma separated list of numeric values with a single header row a...</div><div class="ttdef"><b>Definition:</b> <a href="heft_8py_source.html#l00410">heft.py:410</a></div></div>
<div class="ttc" id="aclassheft_1_1_rank_metric_html"><div class="ttname"><a href="classheft_1_1_rank_metric.html">heft.RankMetric</a></div><div class="ttdoc">The RankMetric class is an Enum that can be used to select which rank metric we should use to priorit...</div><div class="ttdef"><b>Definition:</b> <a href="heft_8py_source.html#l00051">heft.py:51</a></div></div>
<div class="ttc" id="anamespaceheft_html_aaeb46a6ae00e284c982ae2779662366c"><div class="ttname"><a href="namespaceheft.html#aaeb46a6ae00e284c982ae2779662366c">heft.generate_argparser</a></div><div class="ttdeci">def generate_argparser()</div><div class="ttdoc">For when this heft library is being invoked as a standalone commandline application,...</div><div class="ttdef"><b>Definition:</b> <a href="heft_8py_source.html#l00441">heft.py:441</a></div></div>
<div class="ttc" id="anamespaceheft_html_a2d04907ad708a6510d6438eaf8f6394e"><div class="ttname"><a href="namespaceheft.html#a2d04907ad708a6510d6438eaf8f6394e">heft.readCsvToNumpyMatrix</a></div><div class="ttdeci">def readCsvToNumpyMatrix(csv_file)</div><div class="ttdoc">Given an input file consisting of a comma separated list of numeric values with a single header row a...</div><div class="ttdef"><b>Definition:</b> <a href="heft_8py_source.html#l00391">heft.py:391</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_fb424ac5d49dae41a5ded256836588c9.html">heft</a></li><li class="navelem"><a class="el" href="heft_8py.html">heft.py</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
